1-  < infile "grep a1" | "wc -w" > outfile
* < infile : input redirection (<) take the content of the infile and pass them as
  input to the next command(grep);
* | : the vertical bar is used for piping It takes the output of the previous command
  (grep) and passes it as input to the next command (wc).
* > outfile : output redirection (>) to redirect the output of the previous command (wc)
  to the outfile file. The > operator overwrites the content of the outfile file with
  the output generated by the command.
==========astuce -=============
int fd;
fd =open(argv[1], O_RDONLY);
====================functions========================
* strerror : it must include string.h => this function return a string representing
  the error  strerror(errno).

* perror ("message"); => its give the error occured
  ex : message: No such file or directory
  perror("") : if we leave it blank string (chaine vide) it'll actually just output the error message

* access : is used to check the accessibility of a file or directory. It allows you to check whether
  a file can be read, written, or executed, based on the permissions and the user's privileges. The
  function is declared in the (<unistd.h>) header file.
  return 0 if the specified permissions are granted (success) or -1 if an error occurs.
  prototype : int access(const char *path, int mode);
  ex of mode : (R_OK) for read, (W_OK) for write, (X_OK) for execute

* dup && dup2 : ==> #include <unistd.h>
  a - dup : * duplicates an existing file descriptor returning a new file descriptor that
            refers to the same open file description .
            * prototype : int dup(int oldfd);
    int new_fd =  dup(int oldfd);
  b - dup2: * The dup2 function is similar to dup but allows you to specify the desired file
            descriptor number for the duplicate.
            * (La fonction dup2 est similaire à dup mais vous permet de spécifier le numéro de
            descripteur de fichier souhaité pour le doublon).
            * prototype : int dup2(int oldfd, int newfd);
              => 2 steps process:
                   a - closes the newfd (if open)
                   b - copies the fd_table[oldfd] to fd_table[newfd];
        Note : dup2(oldfd, 1) ; => same as close(1), dup(oldfd);
============================================================================
* #include <unistd.h> : is a lunix specific library
* processes = processus = procedure = opération = méthod
===================fork===============
 fork = creates a child process from the main process, that child process  
        is actually very important because that child process has the same exact
        memory as the main (parent) process everything is copied over
 two very important conclusions :
    1- the memory is getting copied value by value variable by variable from one
       process to another process when you do fork.
    2- the two processes execute the same code with different results
 *return  int id = fork();
    -1 =>> for errors
    0 =>> to the new processes (child process)
    id =>> the process id of the new process (children) to the old process ==> the main process (le processus principal)
* every single process in windows, linux everywhere has a process id
 ---fork();
    fork();
    printf("hello world\n"); =>> will print 4 hello world in the terminal
 ---fork();
    fork();
    fork();
    fork();
    printf("hello world\n"); ==> print (number of fork)^2 = 16
4^2 = 16 => n^2 (n : number of fork funtcion)

=============Wait function========================
* Waiting for processes to finish (using the wait function) in C
* is used to wait for the child process
* if(wait(NULL) == -1) =>> Nochildren to wait for

===============Process IDs in c====================
# include <sys/wait.h>
* every single process has an ID a number that is unique for that process.
* every process in the systme has a parent process ID that has launched
* always the child processes should terminate first before tha parent process terminates

===========================(leaf == number of the leaf)===============
* "leaf" refers to a node that does not have any child
* the number of process is number of the leaf.


============================File Descriptor===================
 is a key for access to a file (where we want to read and write)

===========================Communicating between processes (using pipes)=========
* pipe : is a mechanism used for inter process communication between two
         related processes it allows one process to send data to another process
         through a unidirectional communication channel.
* fd[0] ==> read
* fd[1] ==> write
* it can't really have a pipe between to processes that aren't on the same hierarchy

=======================Using execve in c============================
* allows to run or execute a system command from your c program
* system call : is a way for yout program to interact with the operating system
* execve: The execve function is used to execute a specified program. It replaces
  the current process with a new process specified by the given program name and arguments.
* execve(pathname, argv, envp)
 ==> parameters:
    1 - pathname : the pathname of the command to execute
    2 - argv     : The arguments(list of arguments) to pass to  the new program.
    3 - envp     : the environment list.
    Note that atgv and envp are arrays of character pointers.
 execve(av[0], av,NULL); with (av + 1) and av + 2
=========================Environment variables=========================
* there's two ways to read environment variables :
  1 - the first one is by adding a third parameter called char **env.
  2 - the normal way is by declaring an external variable (is the variable
      declared outside any function ) extern char **environment;
* printenv : this command print all environment variables in the terminal.