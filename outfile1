#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/wait.h>

int main() {
    int pipefd[2];
    pid_t cmd1_pid, cmd2_pid;

    // Create a pipe
    if (pipe(pipefd) == -1) {
        perror("pipe");
        return 1;
    }

    // Fork the first child process to execute "cmd1"
    cmd1_pid = fork();
    if (cmd1_pid == -1) {
        perror("fork");
        return 1;
    } else if (cmd1_pid == 0) {
        // Child process: cmd1
        close(pipefd[0]); // Close the read end of the pipe
        dup2(pipefd[1], STDOUT_FILENO); // Redirect stdout to the pipe write end
        close(pipefd[1]); // Close the pipe write end

        // Redirect input from "file1"
        int fd = open("file1", O_RDONLY);
        if (fd == -1) {
            perror("open file1");
            return 1;
        }
        dup2(fd, STDIN_FILENO);
        close(fd);

        // Execute cmd1
        char *cmd1_args[] = { "cmd1", NULL };
        execvp("cmd1", cmd1_args);
        perror("execvp cmd1");
        return 1;
    }

    // Fork the second child process to execute "cmd2"
    cmd2_pid = fork();
    if (cmd2_pid == -1) {
        perror("fork");
        return 1;
    } else if (cmd2_pid == 0) {
        // Child process: cmd2
        close(pipefd[1]); // Close the write end of the pipe
        dup2(pipefd[0], STDIN_FILENO); // Redirect stdin to the pipe read end
        close(pipefd[0]); // Close the pipe read end

        // Redirect output to "file2"
        int fd = open("file2", O_WRONLY | O_CREAT | O_TRUNC, 0666);
        if (fd == -1) {
            perror("open file2");
            return 1;
        }
        dup2(fd, STDOUT_FILENO);
        close(fd);

        // Execute cmd2
        char *cmd2_args[] = { "cmd2", NULL };
        execvp("cmd2", cmd2_args);
        perror("execvp cmd2");
        return 1;
    }

    // Parent process
    close(pipefd[0]); // Close the read end of the pipe
    close(pipefd[1]); // Close the write end of the pipe

    // Wait for both child processes to complete
    waitpid(cmd1_pid, NULL, 0);
    waitpid(cmd2_pid, NULL, 0);

    return 0;
}
/*
 char *PATH_from_envp;
char **mypaths;
char **mycmdargs = ft_split(av[1],' '); // retrieve the line PATH from envp
if(!mycmdargs)
        return (1);
mypaths = ft_split(envp[4], ':');
if(!mypaths)
        return (1);
int  i;
char *cmd;

i = -1;
while (mypaths[++i])
{
    cmd = ft_strjoin(mypaths[i], "/");
    cmd = ft_strjoin(cmd, mycmdargs[0]);
     if(!cmd)
        {
            free(mypaths);
            free(mycmdargs);
            return (1);
        }
    // printf("%s \n",cmd);
    
    execve(cmd, mycmdargs, envp); // if execve succeeds, it exits
    // perror("Error exceve"); 
    free(cmd); // if execve fails, we free and we try a new path
    
}
free(mypaths);
free(mycmdargs);
return (EXIT_FAILURE);
*/